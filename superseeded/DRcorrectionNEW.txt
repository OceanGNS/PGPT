def XXXcorrectDR(lon, lat, timestamp, x_dr_state, gps_lon, gps_lat):
    # Correction for glider dead reckoned locations when underwater
    # using the gps and drift at surface state (approximate currents)
    # Inputs:
    #     m_lon (NMEA format)
    #     m_lat (NMEA format)
    #     m_present_time (unix)
    #     x_dr_state (glider dive state variable)
    #     m_gps_lon (NMEA format)
    #     m_gps_lat  (NMEA format)
    #
    # Output
    #    corr_lon, corr_lat (corrected m_lon, m_lat in decimal degrees)

    #T Fill nan's with previous value
    x_dr_state = x_dr_state.fillna(method='ffill')

    i_si = np.argwhere(np.diff(x_dr_state**2) != 0)
    i_start = np.argwhere(
        np.diff(x_dr_state[i_si[:, 0]]**2, n=2, axis=0) == 18)
    i_start = i_si[i_start[:, 0]]
    i_start = i_start[:, 0]

    # print(np.isnan(lon[i_start[1]]))
    for ki in range(len(i_start)):
        while np.isnan(lon[i_start[ki]]):
            i_start[ki] = i_start[ki] + 1

    # gps location at surface
    # transition x_dr_state from 2->3
    i_end = np.argwhere(np.diff(x_dr_state**2, n=1, axis=0) == 5)
    i_end = i_end[:, 0] + 1
    for ki in range(len(i_end)):
        while (np.isnan(lon[i_end[ki]]) and np.isnan(gps_lon[i_end[ki]])):
            i_end[ki] = i_end[ki] + 1

    # DR location after surfacing
    # transition from 1->2
    i_mid = np.argwhere(np.diff(x_dr_state**2, n=1, axis=0) == 3)
    i_mid = i_mid[:, 0]
    for ki in range(len(i_mid)):
        while np.isnan(lon[i_mid[ki]]):
            i_mid[ki] = i_mid[ki] - 1

    # t_start = timestamp[i_start]
    lon_dif = lon[i_end].to_numpy() - lon[i_mid].to_numpy()
    lat_dif = lat[i_end].to_numpy() - lat[i_mid].to_numpy()
    t_dif = timestamp[i_mid].to_numpy() - timestamp[i_start].to_numpy()
    
    #Why time difference between mid and start? - Taimaz I changed it back to original code as this change broke the results
    #t_dif = timestamp[i_end].to_numpy() - timestamp[i_mid].to_numpy()
    
    vlonDD = lon_dif / t_dif
    vlatDD = lat_dif / t_dif

    # we need to initialize loncDD and latcDD
    loncDD = np.array(())
    latcDD = np.array(())

    # ap is the index for the "good" positions used for later padding of values
    ap = np.array(())
    
    for i in range(len(i_start)):
        
        #T Again, why i_start and i_mid, rather than i_mid and i_end?  Below we're using
        #T vlonDD & vlatDD, which are calculated based on i_end & i-mid.
        #T I think there should be 2 loops.  One to cover i_start:i_mid, and on for the
        #T i_mid:i_end interval.
        idtemp = np.arange(i_start[i], i_mid[i] + 1)
        a = (i_start[i] + np.argwhere((~np.isnan(lon[idtemp])).to_numpy())).flatten()
        
        #T What is "ap" used for?
        # it is the index of changed values based on the original array.
        # This index can be used to introduce "nan's" for padding to match array size to original array
        # print(a.size)
        ap = np.hstack((ap, a))
        
        ti = timestamp[a] - timestamp[a[0]]
        loncDD = np.hstack(
            (loncDD, (lon[a] + ti * vlonDD[i]).to_numpy()))
        latcDD = np.hstack(
            (latcDD, (lat[a] + ti * vlatDD[i]).to_numpy()))

    # use ap to pad vectors to original input size of lon,lat
    loncDDs = lon*np.nan
    latcDDs = lon*np.nan

    loncDDs[ap]=loncDD
    latcDDs[ap]=latcDD

    return loncDDs,latcDDs